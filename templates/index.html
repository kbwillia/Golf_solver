<!-- Main HTML for Golf Card Game UI -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Card Game</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: none;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 12px 18px 16px 18px;
            border-radius: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.10);
            width: 60%; /* 100% of the parent container */
            max-width: 900px;
            margin: 18px auto 18px auto;
            min-height: 0;
        }
        .game-setup {
            text-align: center;
            margin-bottom: 18px;
        }
        .game-board {
            display: none;
            margin-top: 0;
        }
        .player-grid {
            margin: 8px 0 6px 0;
            padding: 7px 6px 8px 6px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .four-player-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        .player-grid.current-turn {
            border-color: #007bff;
            background-color: #f8f9fa;
            position: relative;
        }
        .player-grid.current-turn.turn-animate {
            animation: pulse-border 2.5s infinite;
        }
        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(0,123,255,0.5); }
            70% { box-shadow: 0 0 0 8px rgba(0,123,255,0.1); }
            100% { box-shadow: 0 0 0 0 rgba(0,123,255,0.5); }
        }


        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 10px auto;
        }
        .card {
            width: 60px;
            height: 90px;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            margin: 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .card.face-up {
            background: white;
            color: #333;
        }
        .card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }
        .card.public {
            border-color: #28a745;
            box-shadow: 0 0 5px #28a745;
        }
        /* Layered deck effect */
        .card.face-down#deckCard {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow:
                0 2px 4px rgba(0,0,0,0.3),
                0 4px 8px rgba(0,0,0,0.2),
                0 6px 12px rgba(0,0,0,0.1);
            transform: translateZ(0);
            width: 70px;
            height: 100px;
            font-size: 20px;
        }

        /* Discard card styling */
        #discardCard {
            width: 70px;
            height: 100px;
            font-size: 16px;
        }
        .card.face-down#deckCard::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 6px;
            z-index: -1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .card.face-down#deckCard::after {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 4px;
            z-index: -2;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .actions {
            text-align: center;
            margin: 20px 0;
        }
        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .game-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 0 auto;
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%);
            padding: 16px 20px;
            border-radius: 10px;
            width: 320px;
            max-width: 90vw;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18);
        }
        .position-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-items: center;
            align-items: center;
        }
        .main-board {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
            gap: 10px;
            width: 100%;
        }
        .new-flex-layout {
            gap: 18px;
        }
        .left-panel {
            flex: 2;
            min-width: 120;
            margin-right: 0;
            padding-right: 4px;
        }
        .center-panel {
            flex: 1.2;
            min-width: 220px;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        .right-panel.always-right-panel {
            flex: 0 0 260px;
            min-width: 240px;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-start;
            position: relative;
            z-index: 2;
            margin-left: 0;
        }
        .deck-discard-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 7px;
        }
        .card:hover {
            box-shadow: 0 0 10px #007bff, 0 0 5px #764ba2;
            opacity: 0.92;
            cursor: pointer;
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .card.disabled:hover {
            box-shadow: none;
            opacity: 0.5;
        }
        .setup-and-board {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        /* .legend {
            margin-top: 10px;
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-card {
            width: 30px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        .legend-card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
        }
        .legend-card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border: 2px solid #b36b00;
        }
        .legend-card.face-up {
            background: white;
            border: 2px solid #333;
        } */
        /* Drag-and-drop highlight for grid cells */
        .card.drop-target {
            outline: 3px dashed #007bff;
            box-shadow: 0 0 8px #007bff;
        }
        .card.not-droppable {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Drawn card area */
        #drawnCardArea {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
        }
        #drawnCardDisplay {
            margin-bottom: 8px;
            width: 70px;
            height: 100px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
            border-radius: 8px;
            background: white;
            font-weight: bold;
            cursor: grab;
            user-select: none;
        }
        #drawnCardDisplay.dragging {
            opacity: 0.7;
            box-shadow: 0 0 10px #007bff;
        }
        #drawnCardDisplay.playable {
            outline: 3px solid #007bff;
            box-shadow: 0 0 12px #007bff;
            border-color: #007bff;
        }
        #discardCard.faded {
            opacity: 0.4;
            filter: grayscale(80%);
            border-style: dashed;
            cursor: not-allowed;
        }
        #probabilitiesPanelContainer {
            position: fixed; /* Always fixed to right */
            top: 40px;
            right: 20px;
            z-index: 100;
            min-width: 320px;
            max-width: 480px;
            width: 420px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        #probabilitiesPanel {
            margin-top: 0;
            margin-right: 0;
            min-width: 300px;
            max-width: 440px;
            font-size: 1.15em;
            align-self: flex-end;
            padding: 18px 24px;
        }
        .gameover-modal-inside {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            margin-top: 40px;
            z-index: 10;
        }
        .modal-content-inside {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18);
            padding: 24px 18px 18px 18px;
            width: 90%;
            max-width: 260px;
            text-align: center;
        }
        #celebrationPanelContainer {
            position: fixed;
            top: 40px;
            left: 20px;
            z-index: 100;
            min-width: 420px;
            max-width: 600px;
            width: 520px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        #celebrationPanel {
            min-width: 380px;
            max-width: 560px;
            font-size: 1.15em;
            align-self: flex-start;
            padding: 24px 32px;
        }
    </style>
</head>
<body>
    <!-- Main container for the entire app -->
    <div class="container">
        <!-- Header Section (Title) -->
        <div class="header">
            <h1>🏌️ Golf Card Game</h1>
        </div>
        <!-- Setup and Game Board Wrapper -->
        <div class="setup-and-board">
            <!-- Game Setup Panel (shown before game starts) -->
            <div class="game-setup" id="gameSetup">
                <h2>Game Setup</h2>
                <!-- Player Name Input -->
                <p>
                    <label for="playerName">Your Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your name" style="margin-left:8px; padding:4px 8px; border-radius:4px; border:1px solid #ccc; font-size:1em;" />
                </p>
                <!-- Game Mode Dropdown -->
                <p>
                    <label>Game Mode:</label>
                    <select id="gameMode">
                        <option value="1v1">1 vs 1 AI</option>
                        <option value="1v3">1 vs 3 AI</option>
                    </select>
                </p>
                <!-- Opponent Type Dropdown (hidden for 1v3) -->
                <p id="opponentSection">
                    <label>Opponent Type:</label>
                    <select id="opponentType">
                        <option value="random">Random AI</option>
                        <option value="heuristic">Heuristic AI</option>
                        <option value="qlearning">Q-Learning AI</option>
                    </select>
                </p>
                <!-- Number of Holes Dropdown -->
                <p>
                    <label for="numGames">Number of Holes:</label>
                    <select id="numGames" style="margin-left:8px; padding:4px 8px; border-radius:4px; border:1px solid #ccc; font-size:1em;">
                        <option value="1">1</option>
                        <option value="3">3</option>
                        <option value="6">6</option>
                        <option value="9">9</option>
                        <option value="18">18</option>
                    </select>
                </p>
                <!-- Start/Restart Buttons -->
                <button onclick="startGame()" class="btn btn-primary">Start Game</button>
                <button onclick="restartGame()" class="btn btn-secondary" id="restartBtn" style="display:none;">Restart Game</button>
                <!-- Setup View Timer (shows how long bottom cards are visible) -->
                <div id="setupViewTimer" style="margin-top:16px;font-size:1.1em;color:#007bff;font-weight:bold;"></div>
            </div>
            <!-- Main Game Board (shown after game starts) -->
            <div class="game-board" id="gameBoard">
                <!-- Main Board Layout: Left, Center, Right Panels -->
                <div class="main-board new-flex-layout">
                    <!-- Left Panel: Game Info, Player Grids, Celebration GIFs, Match Summary -->
                    <div class="left-panel">
                        <!-- Game Info (current game, round, etc.) -->
                        <div class="game-info" id="gameInfo"></div>
                        <!-- Player Grids (all players' cards) -->
                        <div id="playerGrids"></div>
                    </div>
                    <!-- Center Panel: Deck, Discard, Drawn Card Area -->
                    <div class="center-panel">
                        <div style="display: flex; flex-direction: row; align-items: flex-end;">
                            <!-- Drawn Card Area (shows card drawn from deck) -->
                            <div id="drawnCardArea">
                                <div id="drawnCardDisplay" draggable="true"></div>
                            </div>
                            <!-- Deck and Discard Pile (vertical layout) -->
                            <div class="deck-discard-vertical">
                                <div>
                                    <h4>Deck</h4>
                                    <div class="card face-down" id="deckCard" title="Draw from Deck" onclick="drawFromDeck()"></div>
                                    <div id="deckSize" style="text-align: center; margin-top: 5px; font-size: 12px;"></div>
                                </div>
                                <div>
                                    <h4>Discard</h4>
                                    <div class="card face-up" id="discardCard" title="Take Discard" onclick="takeDiscard()" draggable="true"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Right Panel: Probabilities Panel, Cumulative Score Chart -->
                    <div class="right-panel always-right-panel">
                        <div id="probabilitiesPanelContainer" style="width:100%;margin-top:auto;">
                            <!-- Probabilities Panel (deck composition, odds, etc.) -->
                            <div id="probabilitiesPanel"></div>
                            <!-- Cumulative Score Chart (line chart per round) -->
                            <div style="margin-top:32px;">
                                <canvas id="cumulativeScoreChart" height="180"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Position Selection Modal (for choosing where to place a card) -->
    <div id="positionModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">Select Position</h3>
            <p id="modalMessage">Choose a position:</p>
            <div id="positionButtons" class="position-buttons"></div>
        </div>
    </div>

    <!-- Celebration Panel (shows GIFs and match summary, left side, outside main container) -->
    <div id="celebrationPanelContainer">
        <div id="celebrationPanel"></div>
    </div>

    <!-- Main JavaScript for all UI/game logic -->
    <script>
        let currentGameState = null; // Holds the current game state from backend
        let gameId = null; // Unique game session ID
        let drawnCard = null; // Card drawn from deck
        let currentAction = null; // Current action type
        let dragActive = false; // Drag state for discard
        let draggedDiscardCard = null; // Card being dragged from discard
        let drawnCardData = null; // Data for the currently drawn card
        let drawnCardDragActive = false; // Drag state for drawn card
        let turnAnimateTimeout = null; // Timeout for turn animation
        let lastTurnIndex = null; // Last turn index to detect turn changes
        let setupHideTimeout = null; // Timeout for hiding setup cards
        let setupCardsHidden = false; // Whether setup cards are hidden
        const SETUP_VIEW_SECONDS = 1.2; // Change this value for how long to show bottom cards
        let setupViewInterval = null; // Interval for setup view timer
        const SNAP_THRESHOLD = 110; // pixels

        // Celebration GIFs for human win
        const celebrationGifs = [
            "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaWhleGUwam04bzZ0NnFnaWhybmZiZmM0ajMxc3RwZWNxNG15aHJkMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/xUOwG43OJ9Mzf4exQQ/giphy.gif",
            "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaWhleGUwam04bzZ0NnFnaWhybmZiZmM0ajMxc3RwZWNxNG15aHJkMCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/Zn7rsVqBTPAly/giphy.gif",
            "https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExa2J1bTJ5bXdsNm03cHJqMW8xcGtyMmExM2FibjFqd2k3OW9iMG5nOSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/akiHW8qDydkm4/giphy.gif"
        ];

        // Hide opponent selection for 1v3 mode
        document.getElementById('gameMode').addEventListener('change', function() {
            const opponentSection = document.getElementById('opponentSection');
            opponentSection.style.display = this.value === '1v1' ? 'block' : 'none';
        });

        function showSetupViewTimer(seconds) {
            const timerDiv = document.getElementById('setupViewTimer');
            timerDiv.textContent = `Bottom two cards visible for: ${seconds} second${seconds !== 1 ? 's' : ''}`;
        }

        function hideSetupViewTimer() {
            const timerDiv = document.getElementById('setupViewTimer');
            timerDiv.textContent = '';
        }

        async function startGame() {
            const gameMode = document.getElementById('gameMode').value;
            const opponentType = document.getElementById('opponentType').value;
            const playerName = document.getElementById('playerName').value || 'Human';
            const numGames = parseInt(document.getElementById('numGames').value) || 1;

            try {
                const response = await fetch('/create_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mode: gameMode,
                        opponent: opponentType,
                        player_name: playerName,
                        num_games: numGames
                    })
                });

                const data = await response.json();
                if (data.success && data.game_state && data.game_state.players) {
                    gameId = data.game_id;
                    currentGameState = data.game_state;
                    document.getElementById('gameSetup').style.display = 'none';
                    document.getElementById('gameBoard').style.display = 'block';
                    document.getElementById('restartBtn').style.display = 'inline-block';
                    setupCardsHidden = false;
                    if (setupHideTimeout) clearTimeout(setupHideTimeout);
                    if (setupViewInterval) clearInterval(setupViewInterval);
                    let secondsLeft = SETUP_VIEW_SECONDS;
                    showSetupViewTimer(secondsLeft);
                    setupViewInterval = setInterval(() => {
                        secondsLeft--;
                        if (secondsLeft > 0) {
                            showSetupViewTimer(secondsLeft);
                        } else {
                            hideSetupViewTimer();
                            clearInterval(setupViewInterval);
                        }
                    }, 1000);
                    setupHideTimeout = setTimeout(() => {
                        setupCardsHidden = true;
                        updateGameDisplay();
                        hideSetupViewTimer();
                        if (setupViewInterval) clearInterval(setupViewInterval);
                    }, SETUP_VIEW_SECONDS * 1000);
                    updateGameDisplay();
                } else {
                    console.error('Game start error:', data);
                    alert('Error starting game: ' + (data.error || 'Unexpected response from server. See console for details.'));
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game. Please try again.');
            }
        }

        async function refreshGameState() {
            if (!gameId) return;

            try {
                const response = await fetch(`/game_state/${gameId}`);
                const data = await response.json();
                if (data && !data.error) {
                    currentGameState = data;
                    updateGameDisplay();

                    if (data.game_over) {
                        // Game over - no modal needed
                    }
                }
            } catch (error) {
                console.error('Error refreshing game state:', error);
            }
        }

        function updateGameDisplay() {
            if (!currentGameState) return;

            // Get custom player names
            const playerNames = currentGameState.players.map(p => p.name);
            const currentPlayer = currentGameState.players[currentGameState.current_turn];
            const isHumanTurn = currentPlayer && currentGameState.current_turn === 0;

            // Show current game number and total games
            const roundDisplay = Math.min(currentGameState.round, currentGameState.max_rounds);
            let infoText = `Game ${currentGameState.current_game || 1} of ${currentGameState.num_games || 1} | Round ${roundDisplay}/${currentGameState.max_rounds}`;
            const celebrationPanel = document.getElementById('celebrationPanel');
            celebrationPanel.innerHTML = '';
            // Show AI thinking message if applicable
            if (currentGameState.ai_thinking) {
                celebrationPanel.innerHTML = `<div style="font-size:1.15em;font-weight:bold;text-align:center;background:#28a745;color:white;padding:10px 0 10px 0;border-radius:8px;margin-bottom:18px;">
                    AI is lining up its shot...</div>`;
            } else if (currentGameState.current_turn === 0 && !currentGameState.game_over) {
                celebrationPanel.innerHTML = `<div style="font-size:1.25em;font-weight:bold;text-align:center;background:#007bff;color:white;padding:10px 0 10px 0;border-radius:8px;margin-bottom:18px;">
                    Your Turn!</div>` + celebrationPanel.innerHTML;
            }
            if (currentGameState.game_over) {
                infoText += ' - Game Over!';
                // Show celebratory GIF in left panel if human wins
                let iconHtml = '';
                if (currentGameState.winner === 0) {
                    const gifUrl = celebrationGifs[Math.floor(Math.random() * celebrationGifs.length)];
                    iconHtml = `<img src="${gifUrl}" alt="Golf Celebration" style="width:100%;max-width:320px;max-height:200px;display:block;margin:0 auto;border-radius:12px;box-shadow:0 2px 12px rgba(0,0,0,0.18);object-fit:contain;background:#fff;" />`;
                } else if (typeof currentGameState.winner === 'number') {
                    iconHtml = '🏆'; // AI wins
                }
                celebrationPanel.innerHTML = `<div style="font-size:1.25em;font-weight:bold;text-align:center;background:#007bff;color:white;padding:10px 0 10px 0;border-radius:8px;margin-bottom:18px;">Game Over</div><div style="text-align:center;margin-top:20px;">${iconHtml}</div>`;
            }

            document.getElementById('gameInfo').textContent = infoText;

            // Show match summary if match is over
            if (currentGameState.match_winner && currentGameState.current_game === currentGameState.num_games) {
                let summaryHtml = `<div style="background:#f8f9fa;padding:18px 24px;border-radius:12px;box-shadow:0 2px 12px #eee;margin-bottom:18px;max-width:480px;">
                    <h2 style="text-align:center;">Match Summary</h2>`;
                summaryHtml += `<div style="margin-bottom:10px;"><b>Final Cumulative Scores:</b></div><ul style="padding-left:18px;">`;
                for (let i = 0; i < currentGameState.players.length; i++) {
                    const winnerIcon = (Array.isArray(currentGameState.match_winner) && currentGameState.match_winner.includes(i)) ? ' 🏆' : '';
                    summaryHtml += `<li><b>${playerNames[i]}</b>: ${currentGameState.cumulative_scores[i]}${winnerIcon}</li>`;
                }
                summaryHtml += `</ul>`;
                if (Array.isArray(currentGameState.match_winner) && currentGameState.match_winner.length === 1) {
                    summaryHtml += `<div style="margin-top:12px;font-size:1.2em;text-align:center;color:#007bff;font-weight:bold;">Winner: ${playerNames[currentGameState.match_winner[0]]} 🏆</div>`;
                } else if (Array.isArray(currentGameState.match_winner)) {
                    summaryHtml += `<div style="margin-top:12px;font-size:1.2em;text-align:center;color:#007bff;font-weight:bold;">Winners: ${currentGameState.match_winner.map(i => playerNames[i]).join(', ')} 🏆</div>`;
                }
                summaryHtml += `</div>`;
                celebrationPanel.innerHTML = summaryHtml + celebrationPanel.innerHTML;
            }

            // Update deck size
            document.getElementById('deckSize').textContent = `${currentGameState.deck_size} cards`;

            // Update discard pile
            const discardCard = document.getElementById('discardCard');
            if (currentGameState.discard_top) {
                discardCard.textContent = `${currentGameState.discard_top.rank}${currentGameState.discard_top.suit}`;
            } else {
                discardCard.textContent = '?';
            }

            // Update player grids
            updatePlayerGrids();
            // Update probabilities panel
            updateProbabilitiesPanel();

            // Update cumulative score chart
            updateCumulativeScoreChart();
        }

        function updatePlayerGrids() {
            const container = document.getElementById('playerGrids');
            container.innerHTML = '';
            // Add or remove four-player-grid class
            if (currentGameState.players.length === 4) {
                container.classList.add('four-player-grid');
            } else {
                container.classList.remove('four-player-grid');
            }
            // Only clear timeout and remove animation if turn index changes
            const currentTurnIndex = currentGameState.current_turn;
            if (lastTurnIndex !== currentTurnIndex) {
                if (turnAnimateTimeout) {
                    clearTimeout(turnAnimateTimeout);
                    turnAnimateTimeout = null;
                }
                document.querySelectorAll('.player-grid.current-turn').forEach(el => el.classList.remove('turn-animate'));
            }
            currentGameState.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-grid';
                if (index === currentGameState.current_turn) {
                    playerDiv.classList.add('current-turn'); // Highlight current turn
                }
                const isHuman = index === 0; // Human is always player 0
                const gridHtml = player.grid.map((card, pos) => {
                    if (!card) return '<div class="card face-down">?</div>'; // Empty slot
                    let cardClass = 'card';
                    let displayText = '?';
                    let extraAttrs = '';
                    if (isHuman && pos >= 2) {
                        if (!setupCardsHidden) {
                            cardClass += ' privately-visible'; // Show bottom cards at setup
                            displayText = `${card.rank}${card.suit}`;
                        } else if (card.public) {
                            cardClass += ' face-up public'; // Show if made public
                            displayText = `${card.rank}${card.suit}`;
                        } else {
                            cardClass += ' face-down'; // Hide after setup
                            displayText = '?';
                        }
                    } else if (card.visible) {
                        if (card.public) {
                            cardClass += ' face-up public';
                        } else {
                            cardClass += ' privately-visible';
                        }
                        displayText = `${card.rank}${card.suit}`;
                    } else {
                        cardClass += ' face-down';
                    }
                    // Drag-and-drop for human player
                    if (isHuman && !card.public && currentGameState.current_turn === 0 && !currentGameState.game_over) {
                        // Accept drop from discard or drawn card
                        extraAttrs += ' ondragover="event.preventDefault();this.classList.add(\'drop-target\');"';
                        extraAttrs += ' ondragleave="this.classList.remove(\'drop-target\');"';
                        extraAttrs += ` ondrop="handleDropOnGrid(${pos});this.classList.remove('drop-target');"`;
                        // If in flip mode, add flippable class
                        if (window.flipDrawnMode) {
                            cardClass += ' drop-target flippable';
                        }
                    } else if (isHuman) {
                        extraAttrs += ' class="card not-droppable"';
                    }
                    return `<div class="${cardClass}" data-position="${pos}" ${extraAttrs}>${displayText}</div>`;
                }).join('');
                // Show only the public score for each player, and private score for human
                let scoreText = '';
                let badgeHtml = '';
                if (currentGameState.public_scores && typeof currentGameState.public_scores[index] !== 'undefined') {
                    scoreText = ` - Score: ${currentGameState.public_scores[index]}`;
                    if (currentGameState.cumulative_scores && typeof currentGameState.cumulative_scores[index] !== 'undefined') {
                        scoreText += ` (Cumulative: ${currentGameState.cumulative_scores[index]})`;
                    }
                    if (currentGameState.game_over && index === currentGameState.winner) {
                        scoreText += ' 🏆';
                    }
                }
                playerDiv.innerHTML = `
                    <h3>${player.name} (${player.agent_type})${scoreText}</h3>
                    ${badgeHtml}
                    <div class="grid-container">${gridHtml}</div>
                `;
                container.appendChild(playerDiv);
            });
            // Robust delayed turn animation for human (border pulse)
            if (currentTurnIndex === 0 && !currentGameState.game_over && lastTurnIndex !== currentTurnIndex) {
                turnAnimateTimeout = setTimeout(() => {
                    // Only add animation if still human's turn
                    if (currentGameState.current_turn === 0 && !currentGameState.game_over) {
                        const grids = document.querySelectorAll('.player-grid.current-turn');
                        if (grids.length > 0) {
                            grids[0].classList.add('turn-animate'); // Border pulse
                        }
                    }
                }, 1); // Delay for border pulse (set to 1ms for instant)
            }
            lastTurnIndex = currentTurnIndex;
            // Attach click handler to flippable cards in flip mode
            if (window.flipDrawnMode) {
                document.querySelectorAll('.flippable').forEach(el => {
                    el.onclick = function() {
                        const pos = parseInt(this.getAttribute('data-position'));
                        flipDrawnCardOnGrid(pos);
                    };
                });
            }
        }

        async function takeDiscard() {
            // Check if the discard card is disabled
            const discardCard = document.getElementById('discardCard');
            if (discardCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (!currentGameState.discard_top) {
                alert('No discard pile available!');
                return;
            }

            showPositionModal('Take Discard Card', 'Choose position to place the discard card:', availablePositions, 'take_discard');
        }

        async function drawFromDeck() {
            // Check if the deck card is disabled
            const deckCard = document.getElementById('deckCard');
            if (deckCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (currentGameState.deck_size === 0) {
                alert('No cards left in deck!');
                return;
            }

            try {
                const response = await fetch(`/draw_card/${gameId}`);
                const data = await response.json();

                if (data.success) {
                    showDrawnCardArea(data.drawn_card);
                } else {
                    alert('Error drawing card: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error drawing card:', error);
                alert('Error drawing card. Please try again.');
            }
        }

        function showDrawnCardArea(card) {
            drawnCardData = card;
            const area = document.getElementById('drawnCardArea');
            const display = document.getElementById('drawnCardDisplay');
            display.textContent = `${card.rank}${card.suit}`;
            area.style.display = 'flex';
            display.setAttribute('draggable', 'true');
            display.classList.remove('dragging');
            display.classList.add('playable');
            // Fade the discard card and make it unclickable
            const discardCard = document.getElementById('discardCard');
            discardCard.classList.add('faded');
            discardCard.onclick = null;
            discardCard.setAttribute('tabindex', '-1');
            window.flipDrawnMode = true; // Enable flip mode immediately
            updatePlayerGrids();
        }

        function hideDrawnCardArea() {
            drawnCardData = null;
            drawnCardDragActive = false;
            document.getElementById('drawnCardArea').style.display = 'none';
            document.getElementById('drawnCardDisplay').classList.remove('playable');
            const discardCard = document.getElementById('discardCard');
            discardCard.classList.remove('faded');
            discardCard.onclick = takeDiscard;
            discardCard.setAttribute('tabindex', '0');
            window.flipDrawnMode = false;
        }

        function getAvailablePositions() {
            if (!currentGameState || currentGameState.current_turn !== 0) return [];

            const humanPlayer = currentGameState.players[0];
            const positions = [];

            for (let i = 0; i < humanPlayer.grid.length; i++) {
                const card = humanPlayer.grid[i];
                if (card && !card.public) {  // Card exists but not publicly known
                    positions.push(i);
                }
            }

            return positions;
        }

        function showPositionModal(title, message, positions, actionType) {
            currentAction = actionType;
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;

            const buttonsContainer = document.getElementById('positionButtons');
            buttonsContainer.innerHTML = '';

            // Get the human player's grid
            const humanPlayer = currentGameState.players[0];

            // Create a 2x2 grid of buttons (positions 0-3)
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    const pos = row * 2 + col;
                    if (positions.includes(pos)) {
                        let cardLabel = '?';
                        const card = humanPlayer.grid[pos];
                        if (card) {
                            if (card.visible) {
                                cardLabel = `${card.rank}${card.suit}`;
                            } else {
                                cardLabel = '?';
                            }
                        }
                        const button = document.createElement('button');
                        button.className = 'btn btn-primary';
                        button.textContent = cardLabel;
                        button.onclick = () => executeAction(pos, actionType);
                        buttonsContainer.appendChild(button);
                    } else {
                        // Add an invisible placeholder to keep grid shape
                        const placeholder = document.createElement('div');
                        placeholder.style.visibility = 'hidden';
                        buttonsContainer.appendChild(placeholder);
                    }
                }
            }

            document.getElementById('positionModal').style.display = 'block';
        }

        async function executeAction(position, actionType = null) {
            document.getElementById('positionModal').style.display = 'none';

            const action = {
                game_id: gameId,
                action: {
                    type: actionType || currentAction,
                    position: position
                }
            };

            // Add extra fields based on action type
            if (actionType === 'draw_keep' || currentAction === 'draw_keep') {
                action.action.type = 'draw_deck';
                action.action.keep = true;
            } else if (actionType === 'draw_discard' || currentAction === 'draw_discard') {
                action.action.type = 'draw_deck';
                action.action.keep = false;
                action.action.flip_position = position;
            }

            try {
                const response = await fetch('/make_move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(action)
                });

                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state;
                    updateGameDisplay();
                    // Immediately refresh to catch any AI moves or turn changes
                    refreshGameState();
                    if (data.game_state.game_over) {
                        // Game over - no modal needed
                    }
                } else {
                    console.error('Action failed:', data.error);
                    alert('Action failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error executing action:', error);
                alert('Error executing action. Please try again.');
            }
        }

        function restartGame() {
            currentGameState = null;
            gameId = null;
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('gameSetup').style.display = 'block';
            document.getElementById('restartBtn').style.display = 'none';
            setupCardsHidden = false;
            if (setupHideTimeout) clearTimeout(setupHideTimeout);
            if (setupViewInterval) clearInterval(setupViewInterval);
            showSetupViewTimer(SETUP_VIEW_SECONDS);
            // Clear celebration panel on restart
            const celebrationPanel = document.getElementById('celebrationPanel');
            celebrationPanel.innerHTML = '';
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let modal of modals) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            }
        }

        // Periodically refresh game state to catch AI moves
        setInterval(() => {
            if (gameId && currentGameState && !currentGameState.game_over) {
                refreshGameState();
            }
        }, 1000);

        // Drawn card drag-and-drop logic
        document.addEventListener('DOMContentLoaded', () => {
            const discardCard = document.getElementById('discardCard');
            discardCard.addEventListener('dragstart', (e) => {
                dragActive = true;
                discardCard.classList.add('drop-target');
                // Store the discard card value at drag start
                if (currentGameState && currentGameState.discard_top) {
                    draggedDiscardCard = {
                        rank: currentGameState.discard_top.rank,
                        suit: currentGameState.discard_top.suit
                    };
                } else {
                    draggedDiscardCard = null;
                }
            });
            discardCard.addEventListener('dragend', (e) => {
                dragActive = false;
                discardCard.classList.remove('drop-target');
                draggedDiscardCard = null;
                // Remove highlight from all grid cells
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
            // Drawn card drag logic
            const display = document.getElementById('drawnCardDisplay');
            display.addEventListener('dragstart', (e) => {
                if (!drawnCardData) return e.preventDefault();
                drawnCardDragActive = true;
                display.classList.add('dragging');
            });
            display.addEventListener('dragend', (e) => {
                drawnCardDragActive = false;
                display.classList.remove('dragging');
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
        });

        // Helper to animate snap effect
        function animateSnapToGrid(cardElem, targetElem, callback) {
            const cardRect = cardElem.getBoundingClientRect();
            const targetRect = targetElem.getBoundingClientRect();
            // Create a clone
            const clone = cardElem.cloneNode(true);
            document.body.appendChild(clone);
            clone.style.position = 'fixed';
            clone.style.left = cardRect.left + 'px';
            clone.style.top = cardRect.top + 'px';
            clone.style.width = cardRect.width + 'px';
            clone.style.height = cardRect.height + 'px';
            clone.style.zIndex = 9999;
            clone.style.pointerEvents = 'none';
            clone.style.transition = 'all 0.2s cubic-bezier(.4,1.4,.6,1)';
            // Hide original
            cardElem.style.visibility = 'hidden';
            // Animate to target
            requestAnimationFrame(() => {
                clone.style.left = targetRect.left + 'px';
                clone.style.top = targetRect.top + 'px';
            });
            // After animation, remove clone and callback
            setTimeout(() => {
                clone.remove();
                cardElem.style.visibility = '';
                if (callback) callback();
            }, 200);
        }

        function handleDropOnGrid(pos) {
            // Find the grid cell element
            const gridCells = document.querySelectorAll('.player-grid.current-turn .grid-container .card');
            let targetElem = null;
            gridCells.forEach(cell => {
                if (parseInt(cell.getAttribute('data-position')) === pos) {
                    targetElem = cell;
                }
            });
            // Drawn card drop
            if (drawnCardDragActive && drawnCardData) {
                const drawnCardElem = document.getElementById('drawnCardDisplay');
                if (targetElem && drawnCardElem) {
                    animateSnapToGrid(drawnCardElem, targetElem, () => {
                        executeAction(pos, 'draw_keep');
                        hideDrawnCardArea();
                    });
                } else {
                    executeAction(pos, 'draw_keep');
                    hideDrawnCardArea();
                }
                return;
            }
            // Discard card drop
            if (!dragActive) return;
            if (currentGameState.current_turn !== 0 || currentGameState.game_over || !currentGameState.discard_top) return;
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            if (!draggedDiscardCard ||
                currentGameState.discard_top.rank !== draggedDiscardCard.rank ||
                currentGameState.discard_top.suit !== draggedDiscardCard.suit) {
                alert('The discard card has changed. Please try again.');
                return;
            }
            const discardCardElem = document.getElementById('discardCard');
            if (targetElem && discardCardElem) {
                animateSnapToGrid(discardCardElem, targetElem, () => {
                    executeAction(pos, 'take_discard');
                });
            } else {
                executeAction(pos, 'take_discard');
            }
        }

        function flipDrawnCardOnGrid(pos) {
            if (!window.flipDrawnMode || !drawnCardData) return;
            // Only allow if the position is not public
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            // Discard the drawn card and flip this position
            executeAction(pos, 'draw_discard');
            hideDrawnCardArea();
        }

        function updateProbabilitiesPanel() {
            const panel = document.getElementById('probabilitiesPanel');
            if (!currentGameState || !currentGameState.probabilities) {
                panel.innerHTML = '';
                return;
            }
            const probs = currentGameState.probabilities;
            let html = '<div style="background:#f8f9fa;padding:12px 18px;border-radius:10px;box-shadow:0 1px 4px #eee;">';
            html += '<h4 style="margin-top:0;">Probabilities</h4>';

            // Expected Value Comparison (most important - show first)
            if (probs.expected_value_draw_vs_discard && currentGameState.current_turn === 0 && !currentGameState.game_over) {
                const ev = probs.expected_value_draw_vs_discard;
                html += '<div style="margin-bottom:12px;padding:8px 12px;background:#e8f4fd;border-radius:6px;border-left:4px solid #007bff;">';
                html += '<div style="font-weight:bold;color:#007bff;margin-bottom:4px;">🎯 Strategic Recommendation:</div>';
                html += `<div style="font-size:14px;margin-bottom:2px;"><b>${ev.recommendation}</b></div>`;
                html += `<div style="font-size:12px;color:#666;">Draw: +${ev.draw_expected_value} | Discard: +${ev.discard_expected_value} | Advantage: ${ev.draw_advantage > 0 ? '+' : ''}${ev.draw_advantage}</div>`;
                if (ev.discard_card) {
                    html += `<div style="font-size:12px;color:#666;">Discard: ${ev.discard_card} (score: ${ev.discard_score})</div>`;
                }
                html += '</div>';
            }

            // Deck composition
            if (probs.deck_counts) {
                // Desired order: J, A, 2-10, Q, K
                const order = ['J', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Q', 'K'];
                html += '<div><b>(Unknown Cards left):</b>';
                html += '<table style="font-size:13px;margin-top:4px;margin-bottom:6px;width:50%;border-collapse:collapse;">';
                html += '<thead><tr><th style="text-align:left;padding-right:10px;">Rank</th><th style="text-align:left;">Count</th></tr></thead><tbody>';
                for (const rank of order) {
                    if (probs.deck_counts[rank] !== undefined) {
                        html += `<tr><td style="padding-right:0px;">${rank}</td><td>${probs.deck_counts[rank]}</td></tr>`;
                    }
                }
                html += '</tbody></table></div>';
            }

            // Probability of drawing a pair (for human)
            if (probs.prob_draw_pair && probs.prob_draw_pair.length > 0) {
                html += `<div style="margin-top:4px;">`;
                html += `<b>Prob. next card matches your grid:</b> <span style="color:#007bff;">${probs.prob_draw_pair[0]}</span>`;
                html += '</div>';
            }
            // Probability of drawing a card that improves your hand (for human)
            if (probs.prob_improve_hand && probs.prob_improve_hand.length > 0) {
                html += `<div style="margin-top:4px;">`;
                html += `<b>Prob. next card improves your hand:</b> <span style="color:#007bff;">${probs.prob_improve_hand[0]}</span>`;
                html += '</div>';
            }
            html += '</div>';
            panel.innerHTML = html;
        }

        // Draw a line chart of cumulative scores for all players
        let cumulativeScoreChart = null;
        let lastChartGameId = null;
        let lastChartRound = null;
        function updateCumulativeScoreChart() {
            const ctx = document.getElementById('cumulativeScoreChart').getContext('2d');
            if (!currentGameState || !currentGameState.cumulative_scores || !currentGameState.current_game) return;
            // Build score history for each player, per round
            if (!window.cumulativeScoreHistory || lastChartGameId !== gameId) {
                // Reset history if new game session
                window.cumulativeScoreHistory = [];
                for (let i = 0; i < currentGameState.players.length; i++) {
                    window.cumulativeScoreHistory.push([]);
                }
                window.cumulativeScoreLabels = [];
                lastChartGameId = gameId;
                lastChartRound = null;
            }
            // Always add a point for the first round of the first game if not present
            if (window.cumulativeScoreLabels.length === 0 && currentGameState.round === 1) {
                for (let i = 0; i < currentGameState.players.length; i++) {
                    window.cumulativeScoreHistory[i].push(currentGameState.cumulative_scores[i]);
                }
                window.cumulativeScoreLabels.push('G1R1');
                lastChartRound = 'G1R1';
            }
            // Only update if new round or game over
            const roundKey = `G${currentGameState.current_game}R${currentGameState.round}`;
            if (window.cumulativeScoreLabels[window.cumulativeScoreLabels.length - 1] !== roundKey && (currentGameState.round > 1 || currentGameState.current_game > 1 || currentGameState.game_over)) {
                for (let i = 0; i < currentGameState.players.length; i++) {
                    window.cumulativeScoreHistory[i].push(currentGameState.cumulative_scores[i]);
                }
                window.cumulativeScoreLabels.push(roundKey);
                lastChartRound = roundKey;
            } else if (window.cumulativeScoreLabels[window.cumulativeScoreLabels.length - 1] === roundKey) {
                // No new round, don't update chart
                return;
            }
            // X axis: per round (G1R1, G1R2, ...)
            const labels = window.cumulativeScoreLabels;
            // Colors for each player
            const colors = ['#007bff', '#e67e22', '#28a745', '#764ba2', '#f39c12', '#e74c3c'];
            const datasets = currentGameState.players.map((player, i) => ({
                label: player.name,
                data: window.cumulativeScoreHistory[i],
                borderColor: colors[i % colors.length],
                backgroundColor: colors[i % colors.length],
                fill: false,
                tension: 0.2,
                pointRadius: 1,
                pointHoverRadius: 5
            }));
            if (cumulativeScoreChart) {
                cumulativeScoreChart.data.labels = labels;
                cumulativeScoreChart.data.datasets = datasets;
                cumulativeScoreChart.update();
            } else {
                cumulativeScoreChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: true, position: 'bottom' },
                            title: { display: true, text: 'Cumulative Scores by Round' }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Game & Round' },
                                ticks: { autoSkip: false }
                            },
                            y: {
                                title: { display: true, text: 'Score' },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }

        // Show timer on initial load
        document.addEventListener('DOMContentLoaded', function() {
            showSetupViewTimer(SETUP_VIEW_SECONDS);
        });

        function onDrop(card, slot) {
            const cardRect = card.getBoundingClientRect();
            const slotRect = slot.getBoundingClientRect();

            const dx = cardRect.left - slotRect.left;
            const dy = cardRect.top - slotRect.top;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < SNAP_THRESHOLD) {
                // Snap the card to the slot
                card.style.transition = 'all 0.2s';
                card.style.left = `${slotRect.left}px`;
                card.style.top = `${slotRect.top}px`;
                // Optionally, update your game state here
            } else {
                // Return card to original position or handle as invalid drop
            }
        }
    </script>
</body>
</html>