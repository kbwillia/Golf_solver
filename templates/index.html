<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Card Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
            margin: 0 auto;
        }
        .game-setup {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-board {
            display: none;
        }
        .player-grid {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .player-grid.current-turn {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 10px auto;
        }
        .card {
            width: 60px;
            height: 90px;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            margin: 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .card.face-up {
            background: white;
            color: #333;
        }
        .card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }
        .card.public {
            border-color: #28a745;
            box-shadow: 0 0 5px #28a745;
        }
        /* Layered deck effect */
        .card.face-down#deckCard {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow:
                0 2px 4px rgba(0,0,0,0.3),
                0 4px 8px rgba(0,0,0,0.2),
                0 6px 12px rgba(0,0,0,0.1);
            transform: translateZ(0);
            width: 70px;
            height: 100px;
            font-size: 20px;
        }

        /* Discard card styling */
        #discardCard {
            width: 70px;
            height: 100px;
            font-size: 16px;
        }
        .card.face-down#deckCard::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 6px;
            z-index: -1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .card.face-down#deckCard::after {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 4px;
            z-index: -2;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .actions {
            text-align: center;
            margin: 20px 0;
        }
        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .game-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 0 auto;
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%);
            padding: 16px 20px;
            border-radius: 10px;
            width: 320px;
            max-width: 90vw;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18);
        }
        .position-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-items: center;
            align-items: center;
        }
        .main-board {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
            gap: 40px;
        }
        .left-panel {
            flex: 2;
        }
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 30px;
        }
        .deck-discard-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .card:hover {
            box-shadow: 0 0 10px #007bff, 0 0 5px #764ba2;
            opacity: 0.92;
            cursor: pointer;
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .card.disabled:hover {
            box-shadow: none;
            opacity: 0.5;
        }
        .setup-and-board {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        .legend {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-card {
            width: 30px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        .legend-card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
        }
        .legend-card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border: 2px solid #b36b00;
        }
        .legend-card.face-up {
            background: white;
            border: 2px solid #333;
        }
        /* Drag-and-drop highlight for grid cells */
        .card.drop-target {
            outline: 3px dashed #007bff;
            box-shadow: 0 0 8px #007bff;
        }
        .card.not-droppable {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Drawn card area */
        #drawnCardArea {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
        }
        #drawnCardDisplay {
            margin-bottom: 8px;
            width: 70px;
            height: 100px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
            border-radius: 8px;
            background: white;
            font-weight: bold;
            cursor: grab;
            user-select: none;
        }
        #drawnCardDisplay.dragging {
            opacity: 0.7;
            box-shadow: 0 0 10px #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèåÔ∏è Golf Card Game</h1>
        </div>
        <div class="setup-and-board">
            <div class="game-setup" id="gameSetup">
                <h2>Game Setup</h2>
                <p>
                    <label>Game Mode:</label>
                    <select id="gameMode">
                        <option value="1v1">1 vs 1 AI</option>
                        <option value="1v3">1 vs 3 AI</option>
                    </select>
                </p>
                <p id="opponentSection">
                    <label>Opponent Type:</label>
                    <select id="opponentType">
                        <option value="random">Random AI</option>
                        <option value="heuristic">Heuristic AI</option>
                        <option value="qlearning">Q-Learning AI</option>
                    </select>
                </p>
                <button onclick="startGame()" class="btn btn-primary">Start Game</button>
                <button onclick="restartGame()" class="btn btn-secondary" id="restartBtn" style="display:none;">Restart Game</button>
            </div>
            <div class="game-board" id="gameBoard">
                <div class="main-board">
                    <div class="left-panel">
                        <div class="game-info" id="gameInfo"></div>
                        <div id="playerGrids"></div>
                        <div class="actions" id="actions">
                            <button onclick="takeDiscard()" class="btn btn-primary" id="takeDiscardBtn">Take from Discard</button>
                            <button onclick="drawFromDeck()" class="btn btn-primary" id="drawDeckBtn">Draw from Deck</button>
                        </div>
                    </div>
                    <div class="right-panel">
                        <div style="display: flex; flex-direction: row; align-items: flex-end;">
                            <div id="drawnCardArea">
                                <div id="drawnCardDisplay" draggable="true"></div>
                            </div>
                            <div class="deck-discard-vertical">
                                <div>
                                    <h4>Deck</h4>
                                    <div class="card face-down" id="deckCard" title="Draw from Deck" onclick="drawFromDeck()"></div>
                                    <div id="deckSize" style="text-align: center; margin-top: 5px; font-size: 12px;"></div>
                                </div>
                                <div>
                                    <h4>Discard</h4>
                                    <div class="card face-up" id="discardCard" title="Take Discard" onclick="takeDiscard()" draggable="true"></div>
                                </div>
                            </div>
                        </div>
                        <div class="legend">
                            <h4>Card Legend:</h4>
                            <div class="legend-item">
                                <div class="legend-card face-down"></div>
                                Face-down (unknown)
                            </div>
                            <div class="legend-item">
                                <div class="legend-card privately-visible"></div>
                                Privately visible to you
                            </div>
                            <div class="legend-item">
                                <div class="legend-card face-up"></div>
                                Public (known to all)
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Position Selection Modal -->
    <div id="positionModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">Select Position</h3>
            <p id="modalMessage">Choose a position:</p>
            <div id="positionButtons" class="position-buttons"></div>
        </div>
    </div>

    <script>
        let currentGameState = null;
        let gameId = null;
        let drawnCard = null;
        let currentAction = null;
        let dragActive = false;
        let draggedDiscardCard = null;
        let drawnCardData = null;
        let drawnCardDragActive = false;

        // Hide opponent selection for 1v3 mode
        document.getElementById('gameMode').addEventListener('change', function() {
            const opponentSection = document.getElementById('opponentSection');
            opponentSection.style.display = this.value === '1v1' ? 'block' : 'none';
        });

        async function startGame() {
            const gameMode = document.getElementById('gameMode').value;
            const opponentType = document.getElementById('opponentType').value;

            try {
                const response = await fetch('/create_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mode: gameMode,
                        opponent: opponentType
                    })
                });

                const data = await response.json();
                if (data.success) {
                    gameId = data.game_id;
                    currentGameState = data.game_state;
                    document.getElementById('gameSetup').style.display = 'none';
                    document.getElementById('gameBoard').style.display = 'block';
                    document.getElementById('restartBtn').style.display = 'inline-block';
                    updateGameDisplay();
                } else {
                    alert('Error starting game: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game. Please try again.');
            }
        }

        async function refreshGameState() {
            if (!gameId) return;

            try {
                const response = await fetch(`/game_state/${gameId}`);
                const data = await response.json();
                if (data && !data.error) {
                    currentGameState = data;
                    updateGameDisplay();

                    if (data.game_over) {
                        showGameOverModal();
                    }
                }
            } catch (error) {
                console.error('Error refreshing game state:', error);
            }
        }

        function updateGameDisplay() {
            if (!currentGameState) return;

            // Update game info
            const currentPlayer = currentGameState.players[currentGameState.current_turn];
            const isHumanTurn = currentPlayer && currentPlayer.is_human;

            const roundDisplay = Math.min(currentGameState.round, currentGameState.max_rounds);
            let infoText = `Round ${roundDisplay}/${currentGameState.max_rounds}`;
            if (currentGameState.game_over) {
                infoText += ' - Game Over!';
            } else if (isHumanTurn) {
                infoText += ' - Your Turn';
            } else if (currentPlayer) {
                infoText += ` - ${currentPlayer.name}'s Turn`;
            }

            document.getElementById('gameInfo').textContent = infoText;

            // Update deck size
            document.getElementById('deckSize').textContent = `${currentGameState.deck_size} cards`;

            // Update discard pile
            const discardCard = document.getElementById('discardCard');
            if (currentGameState.discard_top) {
                discardCard.textContent = `${currentGameState.discard_top.rank}${currentGameState.discard_top.suit}`;
            } else {
                discardCard.textContent = '?';
            }

            // Update player grids
            updatePlayerGrids();

            // Update action buttons
            updateActionButtons();
        }

        function updatePlayerGrids() {
            const container = document.getElementById('playerGrids');
            container.innerHTML = '';
            currentGameState.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-grid';
                if (index === currentGameState.current_turn) {
                    playerDiv.classList.add('current-turn');
                }
                const isHuman = index === 0;
                const gridHtml = player.grid.map((card, pos) => {
                    if (!card) return '<div class="card face-down">?</div>';
                    let cardClass = 'card';
                    let displayText = '?';
                    let extraAttrs = '';
                    if (card.visible) {
                        if (card.public) {
                            cardClass += ' face-up public';
                        } else {
                            cardClass += ' privately-visible';
                        }
                        displayText = `${card.rank}${card.suit}`;
                    } else {
                        cardClass += ' face-down';
                    }
                    // Drag-and-drop for human player
                    if (isHuman && !card.public && currentGameState.current_turn === 0 && !currentGameState.game_over) {
                        // Accept drop from discard or drawn card
                        extraAttrs += ' ondragover="event.preventDefault();this.classList.add(\'drop-target\');"';
                        extraAttrs += ' ondragleave="this.classList.remove(\'drop-target\');"';
                        extraAttrs += ` ondrop="handleDropOnGrid(${pos});this.classList.remove('drop-target');"`;
                        // If in flip mode, add flippable class
                        if (window.flipDrawnMode) {
                            cardClass += ' drop-target flippable';
                        }
                    } else if (isHuman) {
                        extraAttrs += ' class="card not-droppable"';
                    }
                    return `<div class="${cardClass}" data-position="${pos}" ${extraAttrs}>${displayText}</div>`;
                }).join('');
                let scoreText = '';
                if (currentGameState.game_over && currentGameState.scores) {
                    scoreText = ` - Score: ${currentGameState.scores[index]}`;
                    if (index === currentGameState.winner) {
                        scoreText += ' üèÜ';
                    }
                }
                playerDiv.innerHTML = `
                    <h3>${player.name} (${player.agent_type})${scoreText}</h3>
                    <div class="grid-container">${gridHtml}</div>
                `;
                container.appendChild(playerDiv);
            });
            // Attach click handler to flippable cards in flip mode
            if (window.flipDrawnMode) {
                document.querySelectorAll('.flippable').forEach(el => {
                    el.onclick = function() {
                        const pos = parseInt(this.getAttribute('data-position'));
                        flipDrawnCardOnGrid(pos);
                    };
                });
            }
        }

        function updateActionButtons() {
            const actionsDiv = document.getElementById('actions');
            const takeDiscardBtn = document.getElementById('takeDiscardBtn');
            const drawDeckBtn = document.getElementById('drawDeckBtn');
            const deckCard = document.getElementById('deckCard');
            const discardCard = document.getElementById('discardCard');

            // Only show actions if it's human's turn and game isn't over
            const isHumanTurn = currentGameState.current_turn === 0;
            const gameNotOver = !currentGameState.game_over;

            actionsDiv.style.display = (isHumanTurn && gameNotOver) ? 'block' : 'none';

            if (isHumanTurn && gameNotOver) {
                // Check if actions are available
                const hasAvailablePositions = getAvailablePositions().length > 0;
                const hasDiscard = currentGameState.discard_top !== null;
                const hasDeck = currentGameState.deck_size > 0;

                const canTakeDiscard = hasAvailablePositions && hasDiscard;
                const canDrawDeck = hasAvailablePositions && hasDeck;

                // Update buttons
                takeDiscardBtn.disabled = !canTakeDiscard;
                drawDeckBtn.disabled = !canDrawDeck;

                // Update card visual states
                if (canTakeDiscard) {
                    discardCard.classList.remove('disabled');
                } else {
                    discardCard.classList.add('disabled');
                }

                if (canDrawDeck) {
                    deckCard.classList.remove('disabled');
                } else {
                    deckCard.classList.add('disabled');
                }
            } else {
                // Not human's turn - disable both cards
                deckCard.classList.add('disabled');
                discardCard.classList.add('disabled');
            }
        }

        async function takeDiscard() {
            // Check if the discard card is disabled
            const discardCard = document.getElementById('discardCard');
            if (discardCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (!currentGameState.discard_top) {
                alert('No discard pile available!');
                return;
            }

            showPositionModal('Take Discard Card', 'Choose position to place the discard card:', availablePositions, 'take_discard');
        }

        async function drawFromDeck() {
            // Check if the deck card is disabled
            const deckCard = document.getElementById('deckCard');
            if (deckCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (currentGameState.deck_size === 0) {
                alert('No cards left in deck!');
                return;
            }

            try {
                const response = await fetch(`/draw_card/${gameId}`);
                const data = await response.json();

                if (data.success) {
                    showDrawnCardArea(data.drawn_card);
                } else {
                    alert('Error drawing card: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error drawing card:', error);
                alert('Error drawing card. Please try again.');
            }
        }

        function showDrawnCardArea(card) {
            drawnCardData = card;
            const area = document.getElementById('drawnCardArea');
            const display = document.getElementById('drawnCardDisplay');
            display.textContent = `${card.rank}${card.suit}`;
            area.style.display = 'flex';
            display.setAttribute('draggable', 'true');
            display.classList.remove('dragging');
            window.flipDrawnMode = true; // Enable flip mode immediately
            updatePlayerGrids();
        }

        function hideDrawnCardArea() {
            drawnCardData = null;
            drawnCardDragActive = false;
            document.getElementById('drawnCardArea').style.display = 'none';
            window.flipDrawnMode = false;
        }

        function getAvailablePositions() {
            if (!currentGameState || currentGameState.current_turn !== 0) return [];

            const humanPlayer = currentGameState.players[0];
            const positions = [];

            for (let i = 0; i < humanPlayer.grid.length; i++) {
                const card = humanPlayer.grid[i];
                if (card && !card.public) {  // Card exists but not publicly known
                    positions.push(i);
                }
            }

            return positions;
        }

        function showPositionModal(title, message, positions, actionType) {
            currentAction = actionType;
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;

            const buttonsContainer = document.getElementById('positionButtons');
            buttonsContainer.innerHTML = '';

            // Get the human player's grid
            const humanPlayer = currentGameState.players[0];

            // Create a 2x2 grid of buttons (positions 0-3)
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    const pos = row * 2 + col;
                    if (positions.includes(pos)) {
                        let cardLabel = '?';
                        const card = humanPlayer.grid[pos];
                        if (card) {
                            if (card.visible) {
                                cardLabel = `${card.rank}${card.suit}`;
                            } else {
                                cardLabel = '?';
                            }
                        }
                        const button = document.createElement('button');
                        button.className = 'btn btn-primary';
                        button.textContent = cardLabel;
                        button.onclick = () => executeAction(pos, actionType);
                        buttonsContainer.appendChild(button);
                    } else {
                        // Add an invisible placeholder to keep grid shape
                        const placeholder = document.createElement('div');
                        placeholder.style.visibility = 'hidden';
                        buttonsContainer.appendChild(placeholder);
                    }
                }
            }

            document.getElementById('positionModal').style.display = 'block';
        }

        async function executeAction(position, actionType = null) {
            document.getElementById('positionModal').style.display = 'none';

            const action = {
                game_id: gameId,
                action: {
                    type: actionType || currentAction,
                    position: position
                }
            };

            // Add extra fields based on action type
            if (actionType === 'draw_keep' || currentAction === 'draw_keep') {
                action.action.type = 'draw_deck';
                action.action.keep = true;
            } else if (actionType === 'draw_discard' || currentAction === 'draw_discard') {
                action.action.type = 'draw_deck';
                action.action.keep = false;
                action.action.flip_position = position;
            }

            try {
                const response = await fetch('/make_move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(action)
                });

                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state;
                    updateGameDisplay();

                    if (data.game_state.game_over) {
                        setTimeout(showGameOverModal, 500);  // Small delay to show final state
                    }
                } else {
                    console.error('Action failed:', data.error);
                    alert('Action failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error executing action:', error);
                alert('Error executing action. Please try again.');
            }
        }

        function showGameOverModal() {
            if (!currentGameState || !currentGameState.scores) return;

            const humanScore = currentGameState.scores[0];
            let resultMessage = `Game Over!\n\nYour score: ${humanScore}\n`;

            if (currentGameState.mode === '1v1') {
                const aiScore = currentGameState.scores[1];
                resultMessage += `AI score: ${aiScore}\n\n`;
                if (humanScore < aiScore) {
                    resultMessage += "üéâ YOU WIN! üéâ";
                } else if (humanScore > aiScore) {
                    resultMessage += "üòî AI wins üòî";
                } else {
                    resultMessage += "ü§ù It's a tie! ü§ù";
                }
            } else {
                // 4-player game
                const agentNames = ["Random AI", "Heuristic AI", "Q-Learning AI"];
                for (let i = 1; i < currentGameState.scores.length; i++) {
                    resultMessage += `${agentNames[i-1]} score: ${currentGameState.scores[i]}\n`;
                }
                resultMessage += "\n";

                if (currentGameState.winner === 0) {
                    resultMessage += "üéâ YOU WIN! üéâ";
                } else {
                    resultMessage += `üòî ${agentNames[currentGameState.winner - 1]} wins üòî`;
                }
            }

            // Show modal with Play Again button
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <h3>Game Over</h3>
                    <pre style="white-space: pre-line;">${resultMessage}</pre>
                    <button onclick="restartGame();this.closest('.modal').remove();" class="btn btn-primary">Play Again</button>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('restartBtn').style.display = 'inline-block';
        }

        function restartGame() {
            currentGameState = null;
            gameId = null;
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('gameSetup').style.display = 'block';
            document.getElementById('restartBtn').style.display = 'none';
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let modal of modals) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            }
        }

        // Periodically refresh game state to catch AI moves
        setInterval(() => {
            if (gameId && currentGameState && !currentGameState.game_over) {
                refreshGameState();
            }
        }, 1000);

        // Drawn card drag-and-drop logic
        document.addEventListener('DOMContentLoaded', () => {
            const discardCard = document.getElementById('discardCard');
            discardCard.addEventListener('dragstart', (e) => {
                dragActive = true;
                discardCard.classList.add('drop-target');
                // Store the discard card value at drag start
                if (currentGameState && currentGameState.discard_top) {
                    draggedDiscardCard = {
                        rank: currentGameState.discard_top.rank,
                        suit: currentGameState.discard_top.suit
                    };
                } else {
                    draggedDiscardCard = null;
                }
            });
            discardCard.addEventListener('dragend', (e) => {
                dragActive = false;
                discardCard.classList.remove('drop-target');
                draggedDiscardCard = null;
                // Remove highlight from all grid cells
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
            // Drawn card drag logic
            const display = document.getElementById('drawnCardDisplay');
            display.addEventListener('dragstart', (e) => {
                if (!drawnCardData) return e.preventDefault();
                drawnCardDragActive = true;
                display.classList.add('dragging');
            });
            display.addEventListener('dragend', (e) => {
                drawnCardDragActive = false;
                display.classList.remove('dragging');
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
        });

        function handleDropOnGrid(pos) {
            if (drawnCardDragActive && drawnCardData) {
                // Keep the drawn card at this position
                executeAction(pos, 'draw_keep');
                hideDrawnCardArea();
                return;
            }
            if (!dragActive) return;
            if (currentGameState.current_turn !== 0 || currentGameState.game_over || !currentGameState.discard_top) return;
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            if (!draggedDiscardCard ||
                currentGameState.discard_top.rank !== draggedDiscardCard.rank ||
                currentGameState.discard_top.suit !== draggedDiscardCard.suit) {
                alert('The discard card has changed. Please try again.');
                return;
            }
            executeAction(pos, 'take_discard');
        }

        function flipDrawnCardOnGrid(pos) {
            if (!window.flipDrawnMode || !drawnCardData) return;
            // Only allow if the position is not public
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            // Discard the drawn card and flip this position
            executeAction(pos, 'draw_discard');
            hideDrawnCardArea();
        }
    </script>
</body>
</html>
