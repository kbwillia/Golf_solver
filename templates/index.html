<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Card Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: none;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 12px 18px 16px 18px;
            border-radius: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.10);
            max-width: none;
            width: calc(100vw - 480px); /* leave space for the probabilities panel */
            margin: 18px 0 18px 0;
            min-height: 0;
        }
        .game-setup {
            text-align: center;
            margin-bottom: 18px;
        }
        .game-board {
            display: none;
            margin-top: 0;
        }
        .player-grid {
            margin: 8px 0 6px 0;
            padding: 7px 6px 8px 6px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .player-grid.current-turn {
            border-color: #007bff;
            background-color: #f8f9fa;
            position: relative;
        }
        .player-grid.current-turn.turn-animate {
            animation: pulse-border 2.5s infinite;
        }
        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(0,123,255,0.5); }
            70% { box-shadow: 0 0 0 8px rgba(0,123,255,0.1); }
            100% { box-shadow: 0 0 0 0 rgba(0,123,255,0.5); }
        }
        .your-turn-badge {
            position: absolute;
            top: 10px;
            right: 18px;
            background: #007bff;
            color: white;
            padding: 4px 14px;
            border-radius: 16px;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,123,255,0.18);
            z-index: 10;
            animation: badge-pop 5.0s cubic-bezier(.68,-0.55,.27,1.55) both;
        }
        @keyframes badge-pop {
            0% { transform: scale(0.7); opacity: 0; }
            60% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 10px auto;
        }
        .card {
            width: 60px;
            height: 90px;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            margin: 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .card.face-up {
            background: white;
            color: #333;
        }
        .card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }
        .card.public {
            border-color: #28a745;
            box-shadow: 0 0 5px #28a745;
        }
        /* Layered deck effect */
        .card.face-down#deckCard {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow:
                0 2px 4px rgba(0,0,0,0.3),
                0 4px 8px rgba(0,0,0,0.2),
                0 6px 12px rgba(0,0,0,0.1);
            transform: translateZ(0);
            width: 70px;
            height: 100px;
            font-size: 20px;
        }

        /* Discard card styling */
        #discardCard {
            width: 70px;
            height: 100px;
            font-size: 16px;
        }
        .card.face-down#deckCard::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 6px;
            z-index: -1;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .card.face-down#deckCard::after {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
            border-radius: 4px;
            z-index: -2;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .actions {
            text-align: center;
            margin: 20px 0;
        }
        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .game-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 0 auto;
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%);
            padding: 16px 20px;
            border-radius: 10px;
            width: 320px;
            max-width: 90vw;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18);
        }
        .position-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-items: center;
            align-items: center;
        }
        .main-board {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
            gap: 10px;
            width: 100%;
        }
        .new-flex-layout {
            gap: 18px;
        }
        .celebration-panel {
            flex: 0 0 90px;
            min-width: 90px;
            max-width: 120px;
            min-height: 350px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            position: relative;
            background: transparent;
            z-index: 2;
        }
        .left-panel {
            flex: 2;
            min-width: 0;
            margin-right: 0;
            padding-right: 4px;
        }
        .center-panel {
            flex: 1.2;
            min-width: 220px;
            max-width: 680px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        .right-panel.always-right-panel {
            flex: 0 0 260px;
            min-width: 240px;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-start;
            position: relative;
            z-index: 2;
            margin-left: 0;
        }
        .deck-discard-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 7px;
        }
        .card:hover {
            box-shadow: 0 0 10px #007bff, 0 0 5px #764ba2;
            opacity: 0.92;
            cursor: pointer;
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .card.disabled:hover {
            box-shadow: none;
            opacity: 0.5;
        }
        .setup-and-board {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .legend {
            margin-top: 10px;
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-card {
            width: 30px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        .legend-card.face-down {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #333;
        }
        .legend-card.privately-visible {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border: 2px solid #b36b00;
        }
        .legend-card.face-up {
            background: white;
            border: 2px solid #333;
        }
        /* Drag-and-drop highlight for grid cells */
        .card.drop-target {
            outline: 3px dashed #007bff;
            box-shadow: 0 0 8px #007bff;
        }
        .card.not-droppable {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Drawn card area */
        #drawnCardArea {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
        }
        #drawnCardDisplay {
            margin-bottom: 8px;
            width: 70px;
            height: 100px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
            border-radius: 8px;
            background: white;
            font-weight: bold;
            cursor: grab;
            user-select: none;
        }
        #drawnCardDisplay.dragging {
            opacity: 0.7;
            box-shadow: 0 0 10px #007bff;
        }
        #drawnCardDisplay.playable {
            outline: 3px solid #007bff;
            box-shadow: 0 0 12px #007bff;
            border-color: #007bff;
        }
        #discardCard.faded {
            opacity: 0.4;
            filter: grayscale(80%);
            border-style: dashed;
            cursor: not-allowed;
        }
        #probabilitiesPanelContainer {
            position: fixed;
            top: 60px;
            right: 40px;
            z-index: 100;
            min-width: 240px;
            max-width: 340px;
            width: 320px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        #probabilitiesPanel {
            margin-top: 0;
            margin-right: 0;
            min-width: 220px;
            max-width: 320px;
            align-self: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🏌️ Golf Card Game</h1>
        </div>
        <div class="setup-and-board">
            <div class="game-setup" id="gameSetup">
                <h2>Game Setup</h2>
                <p>
                    <label>Game Mode:</label>
                    <select id="gameMode">
                        <option value="1v1">1 vs 1 AI</option>
                        <option value="1v3">1 vs 3 AI</option>
                    </select>
                </p>
                <p id="opponentSection">
                    <label>Opponent Type:</label>
                    <select id="opponentType">
                        <option value="random">Random AI</option>
                        <option value="heuristic">Heuristic AI</option>
                        <option value="qlearning">Q-Learning AI</option>
                    </select>
                </p>
                <button onclick="startGame()" class="btn btn-primary">Start Game</button>
                <button onclick="restartGame()" class="btn btn-secondary" id="restartBtn" style="display:none;">Restart Game</button>
                <div id="setupViewTimer" style="margin-top:16px;font-size:1.1em;color:#007bff;font-weight:bold;"></div>
            </div>
            <div class="game-board" id="gameBoard">
                <div class="main-board new-flex-layout">
                    <div class="celebration-panel" id="celebrationPanel"></div>
                    <div class="left-panel">
                        <div class="game-info" id="gameInfo"></div>
                        <div id="playerGrids"></div>
                    </div>
                    <div class="center-panel">
                        <div style="display: flex; flex-direction: row; align-items: flex-end;">
                            <div id="drawnCardArea">
                                <div id="drawnCardDisplay" draggable="true"></div>
                            </div>
                            <div class="deck-discard-vertical">
                                <div>
                                    <h4>Deck</h4>
                                    <div class="card face-down" id="deckCard" title="Draw from Deck" onclick="drawFromDeck()"></div>
                                    <div id="deckSize" style="text-align: center; margin-top: 5px; font-size: 12px;"></div>
                                </div>
                                <div>
                                    <h4>Discard</h4>
                                    <div class="card face-up" id="discardCard" title="Take Discard" onclick="takeDiscard()" draggable="true"></div>
                                </div>
                            </div>
                        </div>
                        <div class="legend">
                            <h4>Card Legend:</h4>
                            <div class="legend-item">
                                <div class="legend-card face-down"></div>
                                Face-down (unknown)
                            </div>
                            <div class="legend-item">
                                <div class="legend-card privately-visible"></div>
                                Privately visible to you
                            </div>
                            <div class="legend-item">
                                <div class="legend-card face-up"></div>
                                Public (known to all)
                            </div>
                        </div>
                    </div>
                    <div class="right-panel always-right-panel">
                        <!-- Probabilities panel moved outside main container -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Position Selection Modal -->
    <div id="positionModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">Select Position</h3>
            <p id="modalMessage">Choose a position:</p>
            <div id="positionButtons" class="position-buttons"></div>
        </div>
    </div>

    <!-- Probabilities Panel: now outside main container for right alignment -->
    <div id="probabilitiesPanelContainer">
        <div id="probabilitiesPanel"></div>
    </div>

    <script>
        let currentGameState = null;
        let gameId = null;
        let drawnCard = null;
        let currentAction = null;
        let dragActive = false;
        let draggedDiscardCard = null;
        let drawnCardData = null;
        let drawnCardDragActive = false;
        let turnAnimateTimeout = null;
        let lastTurnIndex = null;
        let setupHideTimeout = null;
        let setupCardsHidden = false;
        const SETUP_VIEW_SECONDS = 111.3; // Change this value for how long to show bottom cards
        let setupViewInterval = null;

        // Hide opponent selection for 1v3 mode
        document.getElementById('gameMode').addEventListener('change', function() {
            const opponentSection = document.getElementById('opponentSection');
            opponentSection.style.display = this.value === '1v1' ? 'block' : 'none';
        });

        function showSetupViewTimer(seconds) {
            const timerDiv = document.getElementById('setupViewTimer');
            timerDiv.textContent = `Bottom two cards visible for: ${seconds} second${seconds !== 1 ? 's' : ''}`;
        }

        function hideSetupViewTimer() {
            const timerDiv = document.getElementById('setupViewTimer');
            timerDiv.textContent = '';
        }

        async function startGame() {
            const gameMode = document.getElementById('gameMode').value;
            const opponentType = document.getElementById('opponentType').value;

            try {
                const response = await fetch('/create_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mode: gameMode,
                        opponent: opponentType
                    })
                });

                const data = await response.json();
                if (data.success) {
                    gameId = data.game_id;
                    currentGameState = data.game_state;
                    document.getElementById('gameSetup').style.display = 'none';
                    document.getElementById('gameBoard').style.display = 'block';
                    document.getElementById('restartBtn').style.display = 'inline-block';
                    setupCardsHidden = false;
                    if (setupHideTimeout) clearTimeout(setupHideTimeout);
                    if (setupViewInterval) clearInterval(setupViewInterval);
                    let secondsLeft = SETUP_VIEW_SECONDS;
                    showSetupViewTimer(secondsLeft);
                    setupViewInterval = setInterval(() => {
                        secondsLeft--;
                        if (secondsLeft > 0) {
                            showSetupViewTimer(secondsLeft);
                        } else {
                            hideSetupViewTimer();
                            clearInterval(setupViewInterval);
                        }
                    }, 1000);
                    setupHideTimeout = setTimeout(() => {
                        setupCardsHidden = true;
                        updateGameDisplay();
                        hideSetupViewTimer();
                        if (setupViewInterval) clearInterval(setupViewInterval);
                    }, SETUP_VIEW_SECONDS * 1000);
                    updateGameDisplay();
                } else {
                    alert('Error starting game: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game. Please try again.');
            }
        }

        async function refreshGameState() {
            if (!gameId) return;

            try {
                const response = await fetch(`/game_state/${gameId}`);
                const data = await response.json();
                if (data && !data.error) {
                    currentGameState = data;
                    updateGameDisplay();

                    if (data.game_over) {
                        showGameOverModal();
                    }
                }
            } catch (error) {
                console.error('Error refreshing game state:', error);
            }
        }

        function updateGameDisplay() {
            if (!currentGameState) return;

            // Update game info
            const currentPlayer = currentGameState.players[currentGameState.current_turn];
            const isHumanTurn = currentPlayer && currentPlayer.is_human;

            const roundDisplay = Math.min(currentGameState.round, currentGameState.max_rounds);
            let infoText = `Round ${roundDisplay}/${currentGameState.max_rounds}`;
            if (currentGameState.game_over) {
                infoText += ' - Game Over!';
            } else if (isHumanTurn) {
                infoText += ' - Your Turn, draw from deck or discard';
            } else if (currentPlayer) {
                infoText += ` - ${currentPlayer.name}'s Turn`;
            }

            document.getElementById('gameInfo').textContent = infoText;

            // Update deck size
            document.getElementById('deckSize').textContent = `${currentGameState.deck_size} cards`;

            // Update discard pile
            const discardCard = document.getElementById('discardCard');
            if (currentGameState.discard_top) {
                discardCard.textContent = `${currentGameState.discard_top.rank}${currentGameState.discard_top.suit}`;
            } else {
                discardCard.textContent = '?';
            }

            // Update player grids
            updatePlayerGrids();
            // Update probabilities panel
            updateProbabilitiesPanel();
        }

        function updatePlayerGrids() {
            const container = document.getElementById('playerGrids');
            container.innerHTML = '';
            // Only clear timeout and remove animation if turn index changes
            const currentTurnIndex = currentGameState.current_turn;
            if (lastTurnIndex !== currentTurnIndex) {
                if (turnAnimateTimeout) {
                    clearTimeout(turnAnimateTimeout);
                    turnAnimateTimeout = null;
                }
                document.querySelectorAll('.player-grid.current-turn').forEach(el => el.classList.remove('turn-animate'));
            }
            currentGameState.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-grid';
                if (index === currentGameState.current_turn) {
                    playerDiv.classList.add('current-turn');
                }
                const isHuman = index === 0;
                const gridHtml = player.grid.map((card, pos) => {
                    if (!card) return '<div class="card face-down">?</div>';
                    let cardClass = 'card';
                    let displayText = '?';
                    let extraAttrs = '';
                    if (isHuman && pos >= 2) {
                        if (!setupCardsHidden) {
                            cardClass += ' privately-visible';
                            displayText = `${card.rank}${card.suit}`;
                        } else if (card.public) {
                            cardClass += ' face-up public';
                            displayText = `${card.rank}${card.suit}`;
                        } else {
                            cardClass += ' face-down';
                            displayText = '?';
                        }
                    } else if (card.visible) {
                        if (card.public) {
                            cardClass += ' face-up public';
                        } else {
                            cardClass += ' privately-visible';
                        }
                        displayText = `${card.rank}${card.suit}`;
                    } else {
                        cardClass += ' face-down';
                    }
                    // Drag-and-drop for human player
                    if (isHuman && !card.public && currentGameState.current_turn === 0 && !currentGameState.game_over) {
                        // Accept drop from discard or drawn card
                        extraAttrs += ' ondragover="event.preventDefault();this.classList.add(\'drop-target\');"';
                        extraAttrs += ' ondragleave="this.classList.remove(\'drop-target\');"';
                        extraAttrs += ` ondrop="handleDropOnGrid(${pos});this.classList.remove('drop-target');"`;
                        // If in flip mode, add flippable class
                        if (window.flipDrawnMode) {
                            cardClass += ' drop-target flippable';
                        }
                    } else if (isHuman) {
                        extraAttrs += ' class="card not-droppable"';
                    }
                    return `<div class="${cardClass}" data-position="${pos}" ${extraAttrs}>${displayText}</div>`;
                }).join('');
                // Show only the public score for each player, and private score for human
                let scoreText = '';
                let badgeHtml = '';
                if (currentGameState.public_scores && typeof currentGameState.public_scores[index] !== 'undefined') {
                    scoreText = ` - Public Score: ${currentGameState.public_scores[index]}`;
                    if (isHuman && currentGameState.private_scores && typeof currentGameState.private_scores[index] !== 'undefined' && currentGameState.private_scores[index] !== null) {
                        scoreText += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Private: ${currentGameState.private_scores[index]})`;
                    }
                    if (currentGameState.game_over && index === currentGameState.winner) {
                        scoreText += ' 🏆';
                    }
                }
                // Add animated badge for human's turn
                if (isHuman && index === currentGameState.current_turn && !currentGameState.game_over) {
                    badgeHtml = '<div class="your-turn-badge">Your Turn!</div>';
                }
                playerDiv.innerHTML = `
                    <h3>${player.name} (${player.agent_type})${scoreText}</h3>
                    ${badgeHtml}
                    <div class="grid-container">${gridHtml}</div>
                `;
                container.appendChild(playerDiv);
            });
            // Robust delayed turn animation for human
            if (currentTurnIndex === 0 && !currentGameState.game_over && lastTurnIndex !== currentTurnIndex) {
                turnAnimateTimeout = setTimeout(() => {
                    // Only add animation if still human's turn
                    if (currentGameState.current_turn === 0 && !currentGameState.game_over) {
                        const grids = document.querySelectorAll('.player-grid.current-turn');
                        if (grids.length > 0) {
                            grids[0].classList.add('turn-animate');
                        }
                    }
                }, 2000);
            }
            lastTurnIndex = currentTurnIndex;
            // Attach click handler to flippable cards in flip mode
            if (window.flipDrawnMode) {
                document.querySelectorAll('.flippable').forEach(el => {
                    el.onclick = function() {
                        const pos = parseInt(this.getAttribute('data-position'));
                        flipDrawnCardOnGrid(pos);
                    };
                });
            }
        }

        async function takeDiscard() {
            // Check if the discard card is disabled
            const discardCard = document.getElementById('discardCard');
            if (discardCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (!currentGameState.discard_top) {
                alert('No discard pile available!');
                return;
            }

            showPositionModal('Take Discard Card', 'Choose position to place the discard card:', availablePositions, 'take_discard');
        }

        async function drawFromDeck() {
            // Check if the deck card is disabled
            const deckCard = document.getElementById('deckCard');
            if (deckCard.classList.contains('disabled')) {
                return; // Do nothing if disabled
            }

            const availablePositions = getAvailablePositions();
            if (availablePositions.length === 0) {
                alert('No available positions!');
                return;
            }

            if (currentGameState.deck_size === 0) {
                alert('No cards left in deck!');
                return;
            }

            try {
                const response = await fetch(`/draw_card/${gameId}`);
                const data = await response.json();

                if (data.success) {
                    showDrawnCardArea(data.drawn_card);
                } else {
                    alert('Error drawing card: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error drawing card:', error);
                alert('Error drawing card. Please try again.');
            }
        }

        function showDrawnCardArea(card) {
            drawnCardData = card;
            const area = document.getElementById('drawnCardArea');
            const display = document.getElementById('drawnCardDisplay');
            display.textContent = `${card.rank}${card.suit}`;
            area.style.display = 'flex';
            display.setAttribute('draggable', 'true');
            display.classList.remove('dragging');
            display.classList.add('playable');
            // Fade the discard card and make it unclickable
            const discardCard = document.getElementById('discardCard');
            discardCard.classList.add('faded');
            discardCard.onclick = null;
            discardCard.setAttribute('tabindex', '-1');
            window.flipDrawnMode = true; // Enable flip mode immediately
            updatePlayerGrids();
        }

        function hideDrawnCardArea() {
            drawnCardData = null;
            drawnCardDragActive = false;
            document.getElementById('drawnCardArea').style.display = 'none';
            document.getElementById('drawnCardDisplay').classList.remove('playable');
            const discardCard = document.getElementById('discardCard');
            discardCard.classList.remove('faded');
            discardCard.onclick = takeDiscard;
            discardCard.setAttribute('tabindex', '0');
            window.flipDrawnMode = false;
        }

        function getAvailablePositions() {
            if (!currentGameState || currentGameState.current_turn !== 0) return [];

            const humanPlayer = currentGameState.players[0];
            const positions = [];

            for (let i = 0; i < humanPlayer.grid.length; i++) {
                const card = humanPlayer.grid[i];
                if (card && !card.public) {  // Card exists but not publicly known
                    positions.push(i);
                }
            }

            return positions;
        }

        function showPositionModal(title, message, positions, actionType) {
            currentAction = actionType;
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;

            const buttonsContainer = document.getElementById('positionButtons');
            buttonsContainer.innerHTML = '';

            // Get the human player's grid
            const humanPlayer = currentGameState.players[0];

            // Create a 2x2 grid of buttons (positions 0-3)
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    const pos = row * 2 + col;
                    if (positions.includes(pos)) {
                        let cardLabel = '?';
                        const card = humanPlayer.grid[pos];
                        if (card) {
                            if (card.visible) {
                                cardLabel = `${card.rank}${card.suit}`;
                            } else {
                                cardLabel = '?';
                            }
                        }
                        const button = document.createElement('button');
                        button.className = 'btn btn-primary';
                        button.textContent = cardLabel;
                        button.onclick = () => executeAction(pos, actionType);
                        buttonsContainer.appendChild(button);
                    } else {
                        // Add an invisible placeholder to keep grid shape
                        const placeholder = document.createElement('div');
                        placeholder.style.visibility = 'hidden';
                        buttonsContainer.appendChild(placeholder);
                    }
                }
            }

            document.getElementById('positionModal').style.display = 'block';
        }

        async function executeAction(position, actionType = null) {
            document.getElementById('positionModal').style.display = 'none';

            const action = {
                game_id: gameId,
                action: {
                    type: actionType || currentAction,
                    position: position
                }
            };

            // Add extra fields based on action type
            if (actionType === 'draw_keep' || currentAction === 'draw_keep') {
                action.action.type = 'draw_deck';
                action.action.keep = true;
            } else if (actionType === 'draw_discard' || currentAction === 'draw_discard') {
                action.action.type = 'draw_deck';
                action.action.keep = false;
                action.action.flip_position = position;
            }

            try {
                const response = await fetch('/make_move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(action)
                });

                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state;
                    updateGameDisplay();

                    if (data.game_state.game_over) {
                        setTimeout(showGameOverModal, 500);  // Small delay to show final state
                    }
                } else {
                    console.error('Action failed:', data.error);
                    alert('Action failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error executing action:', error);
                alert('Error executing action. Please try again.');
            }
        }

        function showGameOverModal() {
            if (!currentGameState || !currentGameState.scores) return;

            const humanScore = currentGameState.scores[0];
            let resultMessage = `Game Over!\n\nYour score: ${humanScore}\n`;

            if (currentGameState.mode === '1v1') {
                const aiScore = currentGameState.scores[1];
                resultMessage += `AI score: ${aiScore}\n\n`;
                if (humanScore < aiScore) {
                    resultMessage += "🎉 YOU WIN! 🎉";
                } else if (humanScore > aiScore) {
                    resultMessage += "😔 AI wins 😔";
                } else {
                    resultMessage += "🤝 It's a tie! 🤝";
                }
            } else {
                // 4-player game
                const agentNames = ["Random AI", "Heuristic AI", "Q-Learning AI"];
                for (let i = 1; i < currentGameState.scores.length; i++) {
                    resultMessage += `${agentNames[i-1]} score: ${currentGameState.scores[i]}\n`;
                }
                resultMessage += "\n";

                if (currentGameState.winner === 0) {
                    resultMessage += "🎉 YOU WIN! 🎉";
                } else {
                    resultMessage += `😔 ${agentNames[currentGameState.winner - 1]} wins 😔`;
                }
            }

            // Show modal with Play Again button
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <h3>Game Over</h3>
                    <pre style="white-space: pre-line;">${resultMessage}</pre>
                    <button onclick="restartGame();this.closest('.modal').remove();" class="btn btn-primary">Play Again</button>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('restartBtn').style.display = 'inline-block';
        }

        function restartGame() {
            currentGameState = null;
            gameId = null;
            document.getElementById('gameBoard').style.display = 'none';
            document.getElementById('gameSetup').style.display = 'block';
            document.getElementById('restartBtn').style.display = 'none';
            setupCardsHidden = false;
            if (setupHideTimeout) clearTimeout(setupHideTimeout);
            if (setupViewInterval) clearInterval(setupViewInterval);
            showSetupViewTimer(SETUP_VIEW_SECONDS);
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.getElementsByClassName('modal');
            for (let modal of modals) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            }
        }

        // Periodically refresh game state to catch AI moves
        setInterval(() => {
            if (gameId && currentGameState && !currentGameState.game_over) {
                refreshGameState();
            }
        }, 1000);

        // Drawn card drag-and-drop logic
        document.addEventListener('DOMContentLoaded', () => {
            const discardCard = document.getElementById('discardCard');
            discardCard.addEventListener('dragstart', (e) => {
                dragActive = true;
                discardCard.classList.add('drop-target');
                // Store the discard card value at drag start
                if (currentGameState && currentGameState.discard_top) {
                    draggedDiscardCard = {
                        rank: currentGameState.discard_top.rank,
                        suit: currentGameState.discard_top.suit
                    };
                } else {
                    draggedDiscardCard = null;
                }
            });
            discardCard.addEventListener('dragend', (e) => {
                dragActive = false;
                discardCard.classList.remove('drop-target');
                draggedDiscardCard = null;
                // Remove highlight from all grid cells
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
            // Drawn card drag logic
            const display = document.getElementById('drawnCardDisplay');
            display.addEventListener('dragstart', (e) => {
                if (!drawnCardData) return e.preventDefault();
                drawnCardDragActive = true;
                display.classList.add('dragging');
            });
            display.addEventListener('dragend', (e) => {
                drawnCardDragActive = false;
                display.classList.remove('dragging');
                document.querySelectorAll('.card.drop-target').forEach(el => el.classList.remove('drop-target'));
            });
        });

        function handleDropOnGrid(pos) {
            if (drawnCardDragActive && drawnCardData) {
                // Keep the drawn card at this position
                executeAction(pos, 'draw_keep');
                hideDrawnCardArea();
                return;
            }
            if (!dragActive) return;
            if (currentGameState.current_turn !== 0 || currentGameState.game_over || !currentGameState.discard_top) return;
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            if (!draggedDiscardCard ||
                currentGameState.discard_top.rank !== draggedDiscardCard.rank ||
                currentGameState.discard_top.suit !== draggedDiscardCard.suit) {
                alert('The discard card has changed. Please try again.');
                return;
            }
            executeAction(pos, 'take_discard');
        }

        function flipDrawnCardOnGrid(pos) {
            if (!window.flipDrawnMode || !drawnCardData) return;
            // Only allow if the position is not public
            const card = currentGameState.players[0].grid[pos];
            if (!card || card.public) return;
            // Discard the drawn card and flip this position
            executeAction(pos, 'draw_discard');
            hideDrawnCardArea();
        }

        function updateProbabilitiesPanel() {
            const panel = document.getElementById('probabilitiesPanel');
            if (!currentGameState || !currentGameState.probabilities) {
                panel.innerHTML = '';
                return;
            }
            const probs = currentGameState.probabilities;
            let html = '<div style="background:#f8f9fa;padding:12px 18px;border-radius:10px;box-shadow:0 1px 4px #eee;">';
            html += '<h4 style="margin-top:0;">Probabilities</h4>';
            // Deck composition
            if (probs.deck_counts) {
                html += '<div><b>Deck Composition:</b><br><span style="font-size:13px;">';
                for (const [rank, count] of Object.entries(probs.deck_counts)) {
                    html += `${rank}: ${count} &nbsp; `;
                }
                html += '</span></div>';
            }
            // Probability of drawing lower than min faceup (for human)
            if (probs.prob_draw_lower_than_min_faceup && probs.prob_draw_lower_than_min_faceup.length > 0) {
                html += `<div style="margin-top:8px;">`;
                html += `<b>Prob. next card lower than your lowest face-up:</b> <span style="color:#007bff;">${probs.prob_draw_lower_than_min_faceup[0]}</span>`;
                html += '</div>';
            }
            // Probability of drawing a pair (for human)
            if (probs.prob_draw_pair && probs.prob_draw_pair.length > 0) {
                html += `<div style="margin-top:4px;">`;
                html += `<b>Prob. next card matches your grid:</b> <span style="color:#007bff;">${probs.prob_draw_pair[0]}</span>`;
                html += '</div>';
            }
            // Probability of drawing a card that improves your hand (for human)
            if (probs.prob_improve_hand && probs.prob_improve_hand.length > 0) {
                html += `<div style="margin-top:4px;">`;
                html += `<b>Prob. next card improves your hand:</b> <span style="color:#007bff;">${probs.prob_improve_hand[0]}</span>`;
                html += '</div>';
            }
            html += '</div>';
            panel.innerHTML = html;
        }

        // Show timer on initial load
        document.addEventListener('DOMContentLoaded', function() {
            showSetupViewTimer(SETUP_VIEW_SECONDS);
        });
    </script>
</body>
</html>
